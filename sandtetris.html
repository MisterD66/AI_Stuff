<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sandfall-Tetris</title>
    <style>
        body {
            background-color: #0d1117;
            color: #c9d1d9;
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            overflow: hidden;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 20px;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            border: 2px solid #30363d;
        }

        h1 {
            color: #58a6ff;
            font-size: 2.5em;
            text-align: center;
            margin-bottom: 0;
        }

        canvas {
            background-color: #010409;
            border: 2px solid #21262d;
            border-radius: 8px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .info-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 400px;
        }

        .info-panel p {
            margin: 5px 0;
            font-size: 1.1em;
            color: #8b949e;
        }

        .controls-info {
            text-align: center;
            font-size: 0.9em;
            color: #8b949e;
            line-height: 1.4;
            margin-top: 15px;
        }

        .controls-info b {
            color: #c9d1d9;
        }

        .game-over-screen, .welcome-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(22, 27, 34, 0.95);
            padding: 30px 40px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.7);
            border: 2px solid #30363d;
            z-index: 100;
        }

        .game-over-screen h2, .welcome-screen h2 {
            font-size: 2.5em;
            color: #ff7b72;
            margin-top: 0;
        }

        .welcome-screen h2 {
            color: #58a6ff;
        }
        .game-over-screen p, .welcome-screen p {
            font-size: 1.2em;
            color: #c9d1d9;
            margin: 10px 0 20px;
        }

        button {
            padding: 12px 25px;
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
            background-color: #238636;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
        }

        button:hover {
            background-color: #2ea043;
            transform: scale(1.05);
        }

        button:active {
            transform: scale(1);
        }

        @media (max-width: 600px) {
            .game-container {
                padding: 10px;
            }
            h1 {
                font-size: 2em;
            }
            .game-over-screen h2, .welcome-screen h2 {
                font-size: 2em;
            }
            button {
                padding: 10px 20px;
                font-size: 1em;
            }
        }
    </style>
</head>
<body>

<div class="game-container">
    <h1>Sandfall-Tetris</h1>
    <canvas id="gameCanvas"></canvas>
    <div class="info-panel">
        <p>Punkte: <span id="score">0</span></p>
        <p>Level: <span id="level">1</span></p>
    </div>
    <div class="controls-info">
        <b>Pfeiltasten Links/Rechts:</b> Bewegen<br>
        <b>Pfeiltaste Oben:</b> Drehen<br>
        <b>Pfeiltaste Unten:</b> Beschleunigen<br>
        <b>Leertaste:</b> Sofort fallen lassen
    </div>
</div>

<div id="welcomeScreen" class="welcome-screen">
    <h2>Willkommen bei Sandfall-Tetris!</h2>
    <p>Baue einen durchgehenden Sand-Pfad von links nach rechts.<br>Nur die verbundenen Sandk√∂rner verschwinden, danach rieselt der restliche Sand nach!</p>
    <button id="startButton">Spiel starten</button>
</div>

<div id="gameOverScreen" class="game-over-screen" style="display: none;">
    <h2>Game Over!</h2>
    <p>Deine Punktzahl: <span id="finalScore">0</span></p>
    <button id="restartButton">Nochmal versuchen</button>
</div>

<script>
    document.addEventListener("DOMContentLoaded", () => {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const welcomeScreen = document.getElementById('welcomeScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const finalScoreElement = document.getElementById('finalScore');

        // NEW CONSTANTS FOR FINER SAND RESOLUTION
        const BLOCK_TILE_SIZE = 30; // Original Tetris block size in pixels
        const RESOLUTION_FACTOR = 5; // Each tile becomes a 5x5 grid of sand
        const SAND_TILE_SIZE = BLOCK_TILE_SIZE / RESOLUTION_FACTOR; // Size of a single sand grain
        
        // Grid size is adjusted for the finer resolution
        const ROWS = 20 * RESOLUTION_FACTOR;
        const COLS = 10 * RESOLUTION_FACTOR;

        let score = 0;
        let level = 1;
        let dropInterval = 1000; // Milliseconds
        let lastDropTime = 0;
        let isGameOver = false;
        let isGamePaused = true;
        let isClearing = false; // New status to control the animation

        // Adjust canvas size based on tile size
        canvas.width = COLS * SAND_TILE_SIZE;
        canvas.height = ROWS * SAND_TILE_SIZE;

        // Definition of Tetromino shapes and colors
        const tetrominos = {
            'I': { shape: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], color: '#00ffff' }, // Cyan
            'J': { shape: [[1, 0, 0], [1, 1, 1], [0, 0, 0]], color: '#0000ff' }, // Blue
            'L': { shape: [[0, 0, 1], [1, 1, 1], [0, 0, 0]], color: '#ff7f00' }, // Orange
            'O': { shape: [[1, 1], [1, 1]], color: '#ffff00' }, // Yellow
            'S': { shape: [[0, 1, 1], [1, 1, 0], [0, 0, 0]], color: '#00ff00' }, // Green
            'T': { shape: [[0, 1, 0], [1, 1, 1], [0, 0, 0]], color: '#800080' }, // Purple
            'Z': { shape: [[1, 1, 0], [0, 1, 1], [0, 0, 0]], color: '#ff0000' } // Red
        };
        const tetrominoKeys = Object.keys(tetrominos);
        
        // The game grid that stores the sand
        let grid = createEmptyGrid();
        let currentPiece;

        function createEmptyGrid() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        }

        // --- Game state and logic ---

        function generateNewPiece() {
            if (isGameOver) return;
            const randomKey = tetrominoKeys[Math.floor(Math.random() * tetrominoKeys.length)];
            const piece = tetrominos[randomKey];
            currentPiece = {
                shape: piece.shape,
                color: piece.color,
                // Start position in the new, finer grid
                x: Math.floor(COLS / 2) - Math.floor(piece.shape[0].length * RESOLUTION_FACTOR / 2),
                y: 0
            };

            // Check if the new piece collides immediately
            if (checkCollision(currentPiece.x, currentPiece.y, currentPiece.shape)) {
                endGame();
            }
        }

        function rotatePiece() {
            if (!currentPiece) return;
            const newShape = rotateMatrix(currentPiece.shape);
            if (!checkCollision(currentPiece.x, currentPiece.y, newShape)) {
                currentPiece.shape = newShape;
            }
        }

        function rotateMatrix(matrix) {
            // Rotate matrix 90 degrees clockwise
            const N = matrix.length;
            const rotated = Array.from({ length: N }, () => Array(N).fill(0));
            for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                    rotated[j][N - 1 - i] = matrix[i][j];
                }
            }
            return rotated;
        }

        function checkCollision(x, y, shape) {
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col] === 1) {
                        // Collision check with the new resolution
                        for (let sandY = 0; sandY < RESOLUTION_FACTOR; sandY++) {
                            for (let sandX = 0; sandX < RESOLUTION_FACTOR; sandX++) {
                                const newX = x + col * RESOLUTION_FACTOR + sandX;
                                const newY = y + row * RESOLUTION_FACTOR + sandY;
                                if (newX < 0 || newX >= COLS || newY >= ROWS || (newY >= 0 && grid[newY][newX] !== 0)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }

        function mergePieceToGrid() {
            for (let row = 0; row < currentPiece.shape.length; row++) {
                for (let col = 0; col < currentPiece.shape[row].length; col++) {
                    if (currentPiece.shape[row][col] === 1) {
                        // Add 25 sand grains for each block of the tetromino
                        for (let sandY = 0; sandY < RESOLUTION_FACTOR; sandY++) {
                            for (let sandX = 0; sandX < RESOLUTION_FACTOR; sandX++) {
                                const newY = currentPiece.y + row * RESOLUTION_FACTOR + sandY;
                                const newX = currentPiece.x + col * RESOLUTION_FACTOR + sandX;
                                if (newY >= 0 && newX >= 0 && newY < ROWS && newX < COLS) {
                                    grid[newY][newX] = currentPiece.color;
                                }
                            }
                        }
                    }
                }
            }
        }

        function dropPiece() {
            if (isGamePaused || isGameOver || isClearing) return;
            if (currentPiece) {
                if (checkCollision(currentPiece.x, currentPiece.y + 1, currentPiece.shape)) {
                    mergePieceToGrid();
                    checkAndClearPaths();
                } else {
                    currentPiece.y++;
                }
            }
        }

        function fastDrop() {
            if (isGamePaused || isGameOver || isClearing) return;
            while (!checkCollision(currentPiece.x, currentPiece.y + 1, currentPiece.shape)) {
                currentPiece.y++;
            }
            mergePieceToGrid();
            checkAndClearPaths();
        }

        // --- Sand physics and path logic ---

        function checkAndClearPaths() {
            const colorsToCheck = new Set();
            for (let r = 0; r < ROWS; r++) {
                if (grid[r][0] !== 0) {
                    colorsToCheck.add(grid[r][0]);
                }
            }

            for (const color of colorsToCheck) {
                const queue = [];
                const visited = new Set();

                // Find all starting points on the left edge for this color
                for (let r = 0; r < ROWS; r++) {
                    if (grid[r][0] === color) {
                        queue.push([r, 0]);
                        visited.add(`${r},${0}`);
                    }
                }

                while (queue.length > 0) {
                    const [r, c] = queue.shift();
                    
                    if (c === COLS - 1) {
                        // Path found! Start the recursive clearing animation
                        isClearing = true;
                        initiateSandClear(Array.from(visited)); // Pass the connected cells
                        return; // End the function, as we only clear one color per landing
                    }

                    const neighbors = [[r, c + 1], [r, c - 1], [r + 1, c], [r - 1, c]];
                    for (const [nextR, nextC] of neighbors) {
                        if (nextR >= 0 && nextR < ROWS && nextC >= 0 && nextC < COLS &&
                            grid[nextR][nextC] === color && !visited.has(`${nextR},${nextC}`)) {
                            visited.add(`${nextR},${nextC}`);
                            queue.push([nextR, nextC]);
                        }
                    }
                }
            }
            // If no path was found, just generate a new piece
            animateSandFall();
        }

        function initiateSandClear(cellsToClear) {
            let clearedCount = 0;
            const clearingQueue = [...cellsToClear];

            const clearNextBatch = () => {
                if (clearingQueue.length === 0) {
                    // Start the sand falling animation after clearing is done
                    animateSandFall();
                    return;
                }

                // Clear a small group of cells per frame for the animation effect
                const batchSize = Math.max(1, Math.ceil(clearingQueue.length / 10));
                for (let i = 0; i < batchSize; i++) {
                    if (clearingQueue.length === 0) break;
                    const cell = clearingQueue.shift();
                    if (cell) {
                        const [r, c] = cell.split(',').map(Number);
                        if (grid[r][c] !== 0) {
                            grid[r][c] = 0;
                            clearedCount++;
                        }
                    }
                }

                // Add points for the cleared sand grains
                score += clearedCount * 10 * level;
                updateScore();
                clearedCount = 0;

                draw(); // Redraw to show the gaps
                setTimeout(clearNextBatch, 50); // Small delay for the animation
            };

            clearNextBatch();
        }

        function animateSandFall() {
            let stable = true;
            for (let row = ROWS - 2; row >= 0; row--) {
                for (let col = 0; col < COLS; col++) {
                    if (grid[row][col] !== 0) {
                        // If the cell below is empty, the sand falls
                        if (grid[row + 1][col] === 0) {
                            grid[row + 1][col] = grid[row][col];
                            grid[row][col] = 0;
                            stable = false;
                        }
                        // If the cell below is blocked, the sand checks if it can roll sideways
                        else {
                            const leftEmpty = col > 0 && grid[row + 1][col - 1] === 0;
                            const rightEmpty = col < COLS - 1 && grid[row + 1][col + 1] === 0;

                            if (leftEmpty && rightEmpty) {
                                // Randomly roll left or right
                                const direction = Math.random() < 0.5 ? -1 : 1;
                                grid[row + 1][col + direction] = grid[row][col];
                                grid[row][col] = 0;
                                stable = false;
                            } else if (leftEmpty) {
                                grid[row + 1][col - 1] = grid[row][col];
                                grid[row][col] = 0;
                                stable = false;
                            } else if (rightEmpty) {
                                grid[row + 1][col + 1] = grid[row][col];
                                grid[row][col] = 0;
                                stable = false;
                            }
                        }
                    }
                }
            }

            draw(); // Redraw after each animated step
            if (!stable) {
                requestAnimationFrame(animateSandFall); // Continue animation
            } else {
                isClearing = false;
                generateNewPiece(); // Spawns a new piece after all sand has settled
            }
        }

        // --- Render functions ---

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw the game grid
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const cellColor = grid[row][col];
                    if (cellColor !== 0) {
                        // Draw the individual sand grains
                        ctx.fillStyle = cellColor;
                        ctx.fillRect(col * SAND_TILE_SIZE, row * SAND_TILE_SIZE, SAND_TILE_SIZE, SAND_TILE_SIZE);
                        ctx.strokeStyle = '#010409';
                        ctx.strokeRect(col * SAND_TILE_SIZE, row * SAND_TILE_SIZE, SAND_TILE_SIZE, SAND_TILE_SIZE);
                    }
                }
            }

            // Draw the current piece
            if (currentPiece) {
                ctx.fillStyle = currentPiece.color;
                for (let row = 0; row < currentPiece.shape.length; row++) {
                    for (let col = 0; col < currentPiece.shape[row].length; col++) {
                        if (currentPiece.shape[row][col] === 1) {
                            // Draw the tetromino in the new, finer resolution
                            for (let sandY = 0; sandY < RESOLUTION_FACTOR; sandY++) {
                                for (let sandX = 0; sandX < RESOLUTION_FACTOR; sandX++) {
                                    const drawX = (currentPiece.x + col * RESOLUTION_FACTOR + sandX) * SAND_TILE_SIZE;
                                    const drawY = (currentPiece.y + row * RESOLUTION_FACTOR + sandY) * SAND_TILE_SIZE;
                                    ctx.fillRect(drawX, drawY, SAND_TILE_SIZE, SAND_TILE_SIZE);
                                }
                            }
                            ctx.strokeStyle = '#21262d';
                            ctx.strokeRect((currentPiece.x + col * RESOLUTION_FACTOR) * SAND_TILE_SIZE, (currentPiece.y + row * RESOLUTION_FACTOR) * SAND_TILE_SIZE, BLOCK_TILE_SIZE, BLOCK_TILE_SIZE);
                        }
                    }
                }
            }
        }

        // --- Controls and game loop ---

        function gameLoop(timestamp) {
            if (isGamePaused || isGameOver || isClearing) {
                return;
            }

            const deltaTime = timestamp - lastDropTime;
            if (deltaTime > dropInterval) {
                dropPiece();
                lastDropTime = timestamp;
            }

            draw();
            
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (e) => {
            if (isGamePaused || isGameOver || isClearing) return;

            switch (e.key) {
                case 'ArrowLeft':
                    if (!checkCollision(currentPiece.x - RESOLUTION_FACTOR, currentPiece.y, currentPiece.shape)) {
                        currentPiece.x -= RESOLUTION_FACTOR;
                    }
                    break;
                case 'ArrowRight':
                    if (!checkCollision(currentPiece.x + RESOLUTION_FACTOR, currentPiece.y, currentPiece.shape)) {
                        currentPiece.x += RESOLUTION_FACTOR;
                    }
                    break;
                case 'ArrowUp':
                    rotatePiece();
                    break;
                case 'ArrowDown':
                    dropPiece();
                    break;
                case ' ': // Space bar
                    fastDrop();
                    break;
            }
            draw();
        });

        function updateScore() {
            scoreElement.textContent = score;
            let newLevel = Math.floor(score / 500) + 1;
            if (newLevel > level) {
                level = newLevel;
                levelElement.textContent = level;
                dropInterval = Math.max(100, 1000 - (level - 1) * 50);
            }
        }

        function endGame() {
            isGameOver = true;
            finalScoreElement.textContent = score;
            gameOverScreen.style.display = 'flex';
        }

        function startGame() {
            isGamePaused = false;
            isGameOver = false;
            isClearing = false;
            score = 0;
            level = 1;
            dropInterval = 1000;
            grid = createEmptyGrid();
            updateScore();
            welcomeScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            generateNewPiece();
            requestAnimationFrame(gameLoop);
        }

        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);
    });
</script>

</body>
</html>
