<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sakura Drift | Zen Browser Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Noto+Serif+JP:wght@300;500&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #fff5f0;
            font-family: 'Noto Serif JP', serif;
            user-select: none;
            -webkit-user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
            transition: opacity 1s ease;
        }

        .h-text {
            font-family: 'Cinzel', serif;
            color: #5d4037;
            text-shadow: 0 2px 4px rgba(255, 255, 255, 0.5);
        }

        .jap-text {
            font-family: 'Noto Serif JP', serif;
            writing-mode: vertical-rl;
            text-orientation: upright;
            letter-spacing: 0.5em;
            color: #8d6e63;
            opacity: 0.8;
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 245, 240, 0.9);
            backdrop-filter: blur(4px);
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            transition: opacity 0.8s ease;
        }

        .start-btn {
            margin-top: 2rem;
            padding: 1rem 3rem;
            border: 1px solid #8d6e63;
            color: #5d4037;
            background: transparent;
            font-family: 'Cinzel', serif;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.4s ease;
            border-radius: 2px;
        }

        .start-btn:hover {
            background: #8d6e63;
            color: #fff5f0;
            letter-spacing: 2px;
        }
        
        .music-toggle {
            pointer-events: auto;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s;
        }
        .music-toggle:hover { opacity: 1; }

        .haiku-container {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            opacity: 0;
            transition: opacity 2s ease;
            pointer-events: none;
        }

        .show-haiku { opacity: 1; }

        .hit-flash {
            animation: flashRed 0.3s ease-out;
        }
        
        @keyframes flashRed {
            0% { background-color: rgba(100, 0, 0, 0.2); }
            100% { background-color: transparent; }
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="start-screen">
        <h1 class="h-text text-5xl mb-2">Sakura Drift</h1>
        <div class="text-stone-500 italic mb-8">Guide the blossom. Avoid the shadows.</div>
        <div class="text-xs text-stone-400 mb-8">(Sound Enabled)</div>
        <div class="jap-text absolute right-10 top-1/2 -translate-y-1/2 h-64 text-2xl pointer-events-none hidden md:block">
            桜の精霊
        </div>
        <button class="start-btn" onclick="startGame()">Begin Journey</button>
    </div>

    <div id="ui-layer" style="opacity: 0;">
        <div class="flex justify-between items-start w-full">
            <div class="text-stone-600 text-sm tracking-widest">SEASON: <span id="season-display">SPRING</span></div>
            <div class="flex gap-4">
                <div class="text-stone-600 text-sm tracking-widest music-toggle" onclick="toggleAudio()">♪ MUTE</div>
                <div class="text-stone-600 text-sm tracking-widest">HARMONY: <span id="score-display">0</span></div>
            </div>
        </div>
        
        <div id="haiku-box" class="haiku-container">
            <p class="text-stone-700 italic text-lg mb-1" id="haiku-1"></p>
            <p class="text-stone-700 italic text-lg mb-1" id="haiku-2"></p>
            <p class="text-stone-700 italic text-lg" id="haiku-3"></p>
        </div>
    </div>

<script>
/**
 * SAKURA DRIFT - ENHANCED
 * Procedural landscapes & Generative Audio & Enemies
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- Configuration ---
const CONFIG = {
    layers: 5,
    treeFrequency: 0.15, 
    structureFrequency: 0.03,
    waterfallFrequency: 0.02,
    crowSpawnRate: 0.005 // Chance per frame
};

// --- Audio Engine (Web Audio API) ---
const AudioEngine = {
    ctx: null,
    masterGain: null,
    windNode: null,
    isPlaying: false,
    isMuted: false,
    
    init() {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.4;
        this.masterGain.connect(this.ctx.destination);
        
        this.startWind();
        this.isPlaying = true;
    },

    toggle() {
        if (!this.ctx) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();
        
        this.isMuted = !this.isMuted;
        if (this.isMuted) {
            this.masterGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.5);
            document.querySelector('.music-toggle').innerText = "♪ UNMUTE";
        } else {
            this.masterGain.gain.setTargetAtTime(0.4, this.ctx.currentTime, 0.5);
            document.querySelector('.music-toggle').innerText = "♪ MUTE";
        }
    },

    startWind() {
        const bufferSize = 2 * this.ctx.sampleRate;
        const noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const output = noiseBuffer.getChannelData(0);
        
        let lastOut = 0;
        for (let i = 0; i < bufferSize; i++) {
            let white = Math.random() * 2 - 1;
            output[i] = (lastOut + (0.02 * white)) / 1.02;
            lastOut = output[i];
            output[i] *= 3.5; 
        }

        this.windNode = this.ctx.createBufferSource();
        this.windNode.buffer = noiseBuffer;
        this.windNode.loop = true;
        
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        
        const lfo = this.ctx.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.value = 0.1;
        const lfoGain = this.ctx.createGain();
        lfoGain.gain.value = 200;
        
        lfo.connect(lfoGain);
        lfoGain.connect(filter.frequency);
        lfo.start();

        this.windNode.connect(filter);
        filter.connect(this.masterGain);
        this.windNode.start();
    },

    playChime() {
        if (!this.ctx || this.isMuted) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();

        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const notes = [523.25, 587.33, 659.25, 783.99, 880.00, 1046.50, 1174.66];
        osc.frequency.value = notes[Math.floor(Math.random() * notes.length)];
        osc.type = 'sine';

        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 0.02); 
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.5); 

        osc.connect(gain);
        gain.connect(this.masterGain);
        
        osc.start();
        osc.stop(this.ctx.currentTime + 1.5);
    },

    playHit() {
        if (!this.ctx || this.isMuted) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.frequency.value = 100;
        osc.type = 'triangle';
        
        gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);

        osc.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.3); // Pitch drop

        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
    }
};

// --- Game State ---
let isPlaying = false;
let frameCount = 0;
let score = 0;
let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
let targetMouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
let isStunned = false;

// Colors
const COLORS = {
    bgTop: '#fff0f5',
    bgBottom: '#ffe4e1',
    mountains: ['#eaddcf', '#d7ccc8', '#bcaaa4', '#a1887f', '#8d6e63'],
    river: '#aed9e0',
    petal: '#ffb7c5',
    torii: '#d32f2f',
    wood: '#5d4037',
    leaf: '#a5d6a7',
    crow: '#2d2d2d'
};

const HAIKUS = [
    ["The spring sea rising", "And falling,", "All the day long."],
    ["Petals falling", "Unable to resist", "The moonlight."],
    ["Silent spring rain", "The frog starts to sing", "In the pond."],
    ["Startle not", "The grazing deer", "Mountain cherry blossoms."],
    ["A world of dew", "And within every dewdrop", "A world of struggle."],
    ["The river flows", "Whatever the world does", "The river flows."]
];

// Entities
let player = null;
let petals = [];
let dewdrops = [];
let mountains = [];
let crows = [];
let river = null;

// --- Classes ---

class SceneryObject {
    constructor(x, y, type, layerSpeed) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.layerSpeed = layerSpeed;
        this.scale = 0.8 + Math.random() * 0.4;
        this.seed = Math.random();
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.scale, this.scale);

        if (this.type === 'tree') {
            ctx.strokeStyle = COLORS.wood;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(5 * (this.seed - 0.5), -20, 0, -40);
            ctx.stroke();
            ctx.fillStyle = COLORS.petal;
            ctx.globalAlpha = 0.9;
            for(let i=0; i<5; i++) {
                let bx = Math.sin(i * 2) * 15;
                let by = -40 + Math.cos(i * 2) * 10;
                ctx.beginPath();
                ctx.arc(bx, by, 12, 0, Math.PI*2);
                ctx.fill();
            }
        } 
        else if (this.type === 'torii') {
            ctx.fillStyle = COLORS.torii;
            ctx.fillRect(-15, -50, 4, 50);
            ctx.fillRect(11, -50, 4, 50);
            ctx.fillRect(-20, -40, 40, 4);
            ctx.beginPath();
            ctx.moveTo(-25, -50);
            ctx.quadraticCurveTo(0, -55, 25, -50);
            ctx.lineTo(25, -46);
            ctx.quadraticCurveTo(0, -51, -25, -46);
            ctx.fill();
        }
        else if (this.type === 'pagoda') {
            ctx.fillStyle = COLORS.wood;
            ctx.fillRect(-10, -15, 20, 15);
            for(let i=0; i<3; i++) {
                let y = -15 - (i * 12);
                let w = 25 - (i * 5);
                ctx.fillStyle = '#5d4037';
                ctx.beginPath();
                ctx.moveTo(-w, y);
                ctx.lineTo(0, y - 8);
                ctx.lineTo(w, y);
                ctx.lineTo(w-2, y+2);
                ctx.lineTo(-(w-2), y+2);
                ctx.fill();
            }
        }
        else if (this.type === 'waterfall') {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.moveTo(-5, 0);
            ctx.lineTo(-10, 150);
            ctx.lineTo(10, 150);
            ctx.lineTo(5, 0);
            ctx.fill();
            if (Math.random() > 0.5) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.beginPath();
                ctx.arc(0, 140, Math.random() * 10, 0, Math.PI*2);
                ctx.fill();
            }
        }
        ctx.restore();
    }
}

class Mountain {
    constructor(layerIndex) {
        this.layerIndex = layerIndex;
        this.color = COLORS.mountains[layerIndex];
        this.points = [];
        this.decorations = [];
        this.speed = (layerIndex + 1) * 0.3; 
        this.globalX = -200; // Tracks absolute world position for noise
        this.generateInitial();
    }

    generateInitial() {
        let currentScreenX = -200;
        while(currentScreenX < canvas.width + 200) {
            this.addPoint(currentScreenX, this.globalX);
            currentScreenX += 60;
            this.globalX += 60;
        }
    }

    addPoint(screenX, worldX) {
        let baseHeight = canvas.height - (canvas.height * 0.15 * (5 - this.layerIndex));
        if (this.layerIndex === 4) baseHeight = canvas.height + 50;

        // Use worldX for noise generation so terrain doesn't flatten
        let noise = Math.sin(worldX * 0.005 + this.layerIndex) * 40 + Math.sin(worldX * 0.02) * 20;
        let y = baseHeight - noise;
        
        if (this.layerIndex === 4) y = canvas.height - 40 + Math.sin(worldX*0.01)*10;

        this.points.push({x: screenX, y: y});

        if (screenX > -50 && screenX < canvas.width + 150) {
            this.addDecoration(screenX, y);
        }
    }

    addDecoration(x, y) {
        let slope = 0;
        if (this.points.length > 1) {
            slope = Math.abs(y - this.points[this.points.length-2].y);
        }

        if (slope < 10 && Math.random() < CONFIG.structureFrequency) {
            let type = Math.random() > 0.5 ? 'torii' : 'pagoda';
            if(this.layerIndex > 0 && this.layerIndex < 3) {
                this.decorations.push(new SceneryObject(x, y, type, this.speed));
            }
        } else if (Math.random() < CONFIG.treeFrequency) {
            this.decorations.push(new SceneryObject(x, y, 'tree', this.speed));
        } else if (slope > 15 && Math.random() < CONFIG.waterfallFrequency && this.layerIndex < 3) {
            this.decorations.push(new SceneryObject(x, y, 'waterfall', this.speed));
        }
    }

    update() {
        this.points.forEach(p => p.x -= this.speed);
        this.decorations.forEach(d => d.x -= this.speed);

        if (this.points.length > 0 && this.points[0].x < -200) {
            this.points.shift();
        }
        this.decorations = this.decorations.filter(d => d.x > -200);
        
        let lastPoint = this.points[this.points.length - 1];
        if (lastPoint && lastPoint.x < canvas.width + 200) {
            let newX = lastPoint.x + 60;
            this.addPoint(newX, this.globalX);
            this.globalX += 60; // Advance the noise generator
        }
    }

    draw() {
        this.decorations.forEach(d => {
            if (d.type === 'waterfall') d.draw(ctx);
        });

        if (this.points.length < 2) return;

        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(this.points[0].x, canvas.height);
        ctx.lineTo(this.points[0].x, this.points[0].y);
        
        for (let i = 0; i < this.points.length - 1; i++) {
            let p1 = this.points[i];
            let p2 = this.points[i+1];
            let cx = (p1.x + p2.x) / 2;
            let cy = (p1.y + p2.y) / 2;
            ctx.quadraticCurveTo(p1.x, p1.y, cx, cy);
        }
        
        let last = this.points[this.points.length-1];
        ctx.lineTo(last.x, last.y);
        ctx.lineTo(last.x, canvas.height);
        ctx.lineTo(this.points[0].x, canvas.height);
        ctx.closePath();
        ctx.fill();

        this.decorations.forEach(d => {
            if (d.type !== 'waterfall') d.draw(ctx);
        });
    }
}

class River {
    constructor() {
        this.y = canvas.height - 50;
        this.offset = 0;
    }
    draw() {
        this.offset += 0.5;
        ctx.fillStyle = COLORS.river;
        ctx.beginPath();
        ctx.moveTo(0, canvas.height);
        for(let x=0; x<=canvas.width; x+=20) {
            let y = this.y + Math.sin((x + this.offset) * 0.02) * 10;
            ctx.lineTo(x, y);
        }
        ctx.lineTo(canvas.width, canvas.height);
        ctx.fill();
        ctx.fillStyle = "rgba(255,255,255,0.3)";
        for(let i=0; i<10; i++) {
            let sx = (frameCount * 2 + i * 100) % canvas.width;
            let sy = this.y + 20 + Math.sin(i)*10;
            ctx.fillRect(sx, sy, 30, 2);
        }
    }
}

class Crow {
    constructor() {
        this.x = canvas.width + 50;
        this.y = Math.random() * (canvas.height * 0.6) + 50;
        this.size = 15;
        this.speed = Math.random() * 2 + 2;
        this.flapSpeed = 0.1 + Math.random() * 0.1;
    }

    update() {
        this.x -= this.speed;
        this.y += Math.sin(frameCount * this.flapSpeed) * 2;
        
        // Check collision
        if (!isStunned) {
            let dx = this.x - player.x;
            let dy = this.y - player.y;
            if (Math.sqrt(dx*dx + dy*dy) < 25) {
                hitPlayer();
            }
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.fillStyle = COLORS.crow;
        
        // Bird Shape
        ctx.beginPath();
        ctx.moveTo(10, 0);
        // Wing flap
        let wingY = Math.sin(frameCount * 0.3) * 10;
        ctx.lineTo(-5, -wingY - 5); // Top wing
        ctx.lineTo(-10, 0); // Tail
        ctx.lineTo(-5, wingY + 5); // Bottom wing
        ctx.fill();
        
        // Eye
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(5, -2, 1, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }
}

class Petal {
    constructor(isPlayer = false) {
        this.isPlayer = isPlayer;
        this.x = isPlayer ? canvas.width/2 : Math.random() * canvas.width;
        this.y = isPlayer ? canvas.height/2 : -20;
        this.size = isPlayer ? 12 : Math.random() * 5 + 3;
        this.angle = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.05;
        this.vx = 0;
        this.vy = 0;
        this.color = COLORS.petal;
        this.swayFreq = Math.random() * 0.05 + 0.01;
        this.fallSpeed = Math.random() * 1 + 0.5;
        this.life = 1.0;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.scale(this.life, this.life);

        ctx.fillStyle = this.isPlayer ? '#ff80ab' : this.color;
        if (this.isPlayer) {
            ctx.shadowBlur = isStunned ? 0 : 15;
            ctx.shadowColor = "#ff80ab";
            if (isStunned) ctx.fillStyle = '#888'; // Grey when stunned
        }

        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.bezierCurveTo(-this.size, -this.size/2, -this.size, this.size/2, 0, this.size);
        ctx.bezierCurveTo(this.size, this.size/2, this.size, -this.size/2, 0, 0);
        ctx.fill();
        
        ctx.strokeStyle = "rgba(255,255,255,0.5)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(0, this.size * 0.6);
        ctx.stroke();
        ctx.restore();
    }

    update() {
        this.angle += this.rotationSpeed;
        if (this.isPlayer) {
            if (isStunned) {
                // Drift uncontrollably
                this.x -= 2;
                this.y += 1;
                this.angle += 0.2;
            } else {
                let dx = targetMouse.x - this.x;
                let dy = targetMouse.y - this.y;
                this.x += dx * 0.05;
                this.y += dy * 0.05;
            }

            if (frameCount % 5 === 0 && !isStunned) {
                let p = new Petal(false);
                p.x = this.x; p.y = this.y;
                p.vx = (Math.random() - 0.5) * 2; p.vy = Math.random() * 2;
                p.size = 4; p.life = 0.8; p.decay = true;
                petals.push(p);
            }
        } else {
            if (this.decay) {
                this.life -= 0.01;
                this.x += this.vx; this.y += this.vy;
            } else {
                this.x += Math.sin(frameCount * this.swayFreq) + 0.5;
                this.y += this.fallSpeed;
            }
        }
    }
}

class DewDrop {
    constructor() { this.reset(); }
    reset() {
        this.x = canvas.width + 50;
        this.y = Math.random() * (canvas.height * 0.7);
        this.size = 6;
        this.active = true;
        this.pulseOffset = Math.random() * 100;
    }
    update() {
        this.x -= 2;
        this.y += Math.sin((frameCount + this.pulseOffset) * 0.05) * 0.5;
        
        let dx = this.x - player.x;
        let dy = this.y - player.y;
        if (Math.sqrt(dx*dx+dy*dy) < 30 && this.active && !isStunned) {
            this.collect();
        }
        if (this.x < -50) this.reset();
    }
    collect() {
        this.active = false;
        score++;
        document.getElementById('score-display').innerText = score;
        createExplosion(this.x, this.y);
        AudioEngine.playChime(); 
        if (score % 5 === 0) showHaiku();
        setTimeout(() => this.reset(), 2000);
    }
    draw() {
        if (!this.active) return;
        let pulse = 1 + Math.sin((frameCount + this.pulseOffset) * 0.1) * 0.3;
        ctx.save();
        ctx.translate(this.x, this.y);
        let g = ctx.createRadialGradient(0,0, 2, 0,0, 15);
        g.addColorStop(0, 'rgba(255, 215, 0, 1)');
        g.addColorStop(1, 'rgba(255, 215, 0, 0)');
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(0, 0, 15 * pulse, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(0, 0, this.size/2, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    }
}

// --- Setup & Loop ---

function init() {
    resize();
    mountains = [];
    for(let i=0; i<CONFIG.layers; i++) mountains.push(new Mountain(i));
    river = new River();
    player = new Petal(true);
    dewdrops = [];
    crows = [];
    for(let i=0; i<3; i++) {
        let d = new DewDrop();
        d.x = Math.random() * canvas.width;
        dewdrops.push(d);
    }

    window.addEventListener('mousemove', e => {
        targetMouse.x = e.clientX;
        targetMouse.y = e.clientY;
    });
    window.addEventListener('touchmove', e => {
        e.preventDefault();
        targetMouse.x = e.touches[0].clientX;
        targetMouse.y = e.touches[0].clientY;
    }, {passive: false});
}

function hitPlayer() {
    if (isStunned) return;
    isStunned = true;
    score = Math.max(0, score - 5);
    document.getElementById('score-display').innerText = score;
    AudioEngine.playHit();
    
    // Visual Flash
    const flash = document.createElement('div');
    flash.className = 'absolute top-0 left-0 w-full h-full pointer-events-none z-50 hit-flash';
    document.body.appendChild(flash);
    setTimeout(() => flash.remove(), 300);

    setTimeout(() => {
        isStunned = false;
    }, 1000);
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    if(mountains.length > 0) {
        // Re-init to prevent visual glitching on resize for now
        // Or just let it clear and redraw
    }
}

function createExplosion(x, y) {
    for(let i=0; i<12; i++) {
        let p = new Petal(false);
        p.x = x; p.y = y;
        p.size = Math.random() * 6 + 4;
        p.color = '#ffd700';
        let ang = (Math.PI * 2 / 12) * i;
        let speed = Math.random() * 3 + 2;
        p.vx = Math.cos(ang) * speed;
        p.vy = Math.sin(ang) * speed;
        p.decay = true; p.life = 1.5;
        petals.push(p);
    }
}

function showHaiku() {
    const box = document.getElementById('haiku-box');
    const haiku = HAIKUS[Math.floor(Math.random() * HAIKUS.length)];
    document.getElementById('haiku-1').innerText = haiku[0];
    document.getElementById('haiku-2').innerText = haiku[1];
    document.getElementById('haiku-3').innerText = haiku[2];
    box.classList.add('show-haiku');
    setTimeout(() => box.classList.remove('show-haiku'), 6000);
}

function toggleAudio() { AudioEngine.toggle(); }

function startGame() {
    document.getElementById('start-screen').style.opacity = 0;
    AudioEngine.init();
    setTimeout(() => {
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('ui-layer').style.opacity = 1;
        isPlaying = true;
        init();
        animate();
    }, 800);
}

function animate() {
    if (!isPlaying) return;
    frameCount++;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    let grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    grad.addColorStop(0, COLORS.bgTop);
    grad.addColorStop(1, COLORS.bgBottom);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    mountains.forEach(m => { m.update(); m.draw(); });
    river.draw();

    // Spawn Enemies
    if (Math.random() < CONFIG.crowSpawnRate) crows.push(new Crow());

    if (Math.random() < 0.05) petals.push(new Petal(false));

    // Enemies
    for (let i = crows.length - 1; i >= 0; i--) {
        let c = crows[i];
        c.update();
        c.draw();
        if (c.x < -50) crows.splice(i, 1);
    }

    for (let i = petals.length - 1; i >= 0; i--) {
        let p = petals[i];
        p.update();
        p.draw();
        if (p.y > canvas.height + 50 || p.x > canvas.width + 50 || (p.decay && p.life <= 0)) {
            petals.splice(i, 1);
        }
    }

    dewdrops.forEach(d => { d.update(); d.draw(); });
    if (player) { player.update(); player.draw(); }

    requestAnimationFrame(animate);
}

window.addEventListener('resize', () => {
    if(!isPlaying) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
});
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

</script>
</body>
</html>
